.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Class::Moose::Tutorial 3pm"
.TH Test::Class::Moose::Tutorial 3pm "2014-04-16" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Class::Moose::Tutorial \- A starting guide for Test::Class::Moose
.SH "VERSION"
.IX Header "VERSION"
version 0.54
.SH "Getting Started"
.IX Header "Getting Started"
Automated testing is wonderful. Verifying your program's correctness in all
possible ways is a good thing that will save you time (and programmer time is
money).
.PP
Procedural tests like \f(CW\*(C`Test::More\*(C'\fR are a good, general way to write tests for
all kinds of things. However, it is not very good when you're trying describe
relationships between tests. For this, a class-based test would work better,
because you could use the standard OO-techniques for describing object
relationships like inheritance.
.PP
When testing objects, it's good for code re-use to have test classes that match
the relationships between the regular objects. By creating test classes with
the same relationships, you can quickly increase test coverage by testing the
base class, and all the child classes can inherit those tests!
.SS "A Test Class"
.IX Subsection "A Test Class"
The first and most crucial part of using \f(CW\*(C`Test::Class::Moose\*(C'\fR is a class that
runs some tests. \f(CW\*(C`Test::Class::Moose\*(C'\fR loads a few modules for you
automatically, so the boilerplate is, at minimum:
.PP
.Vb 2
\&    package TestsFor::My::Test::Class;
\&    use Test::Class::Moose;
.Ve
.PP
\&\f(CW\*(C`Test::Class::Moose\*(C'\fR loads \f(CW\*(C`strict\*(C'\fR, \f(CW\*(C`warnings\*(C'\fR, \f(CW\*(C`Moose\*(C'\fR, and
\&\f(CW\*(C`Test::Most\*(C'\fR (which includes \f(CW\*(C`Test::More\*(C'\fR, \f(CW\*(C`Test::Deep\*(C'\fR,
\&\f(CW\*(C`Test::Exception\*(C'\fR, and \f(CW\*(C`Test::Differences\*(C'\fR).
.PP
I put my test classes in the \f(CW\*(C`t/lib/TestsFor\*(C'\fR directory, to keep the
separated from my other classes that help testing (\f(CW\*(C`t/lib\*(C'\fR) and my other test
scripts. This is just a convention; the directory can be anything you want it
to be, but it is a good idea to keep your test classes separate from your
other test-related modules.
.PP
Now, we need a method that runs our test. \f(CW\*(C`Test::Class::Moose\*(C'\fR test
methods start with \f(CW\*(C`test_\*(C'\fR. Any method that starts with \f(CW\*(C`test_\*(C'\fR will be run
as a test.
.PP
.Vb 1
\&    use My::Module;
\&
\&    sub test_construction {
\&        my $test = shift;
\&        my $obj = My::Module\->new;
\&        isa_ok $obj, \*(AqMy::Module\*(Aq;
\&    }
.Ve
.PP
Every \f(CW\*(C`test_\*(C'\fR method is run as a subtest, and no plan is required. We can have as
many \f(CW\*(C`test_\*(C'\fR methods as we want.
.SS "A Test Runner"
.IX Subsection "A Test Runner"
Now that we have a test class, we need a way for prove to load and run them.
\&\f(CW\*(C`Test::Class::Moose\*(C'\fR can load our test modules from a given directory, and it
has a \fIruntests()\fR method that will run any test modules that have already been
loaded.
.PP
.Vb 5
\&    # t/test_class_tests.t
\&    use File::Spec::Functions qw( catdir );
\&    use FindBin qw( $Bin );
\&    use Test::Class::Moose::Load qw( catdir( $Bin, \*(Aqt\*(Aq, \*(Aqlib\*(Aq ) );
\&    Test::Class::Moose\->new\->runtests;
.Ve
.PP
Or if you're not worried about the portability of that directory:
.PP
.Vb 2
\&    use Test::Class::Moose::Load \*(Aqt/lib\*(Aq;
\&    Test::Class::Moose\->new\->runtests;
.Ve
.PP
This test script will load all of the \f(CW\*(C`Test::Class::Moose\*(C'\fR modules inside
\&\f(CW\*(C`t/lib/\*(C'\fR and then run them. All your test modules get run by this one script,
but since they're run as subtests, you will get a report on how many test
classes failed.
.PP
We can run our test script using prove. I'll turn on verbose output (\-v) to
show you what the \s-1TAP\s0 output looks like
.PP
.Vb 10
\&    prove \-v t/test_class_tests.t
\&    t/test_class_tests.t ..
\&    1..1
\&    #
\&    # Running tests for TestsFor::My::Class
\&    #
\&        1..1
\&        # TestsFor::My::Class\->test_something()
\&            ok 1 \- I tested something!
\&            1..1
\&        ok 1 \- test_something
\&    ok 1 \- TestsFor::My::Class
\&    ok
\&    All tests successful.
\&    Files=1, Tests=1,  0 wallclock secs ( 0.03 usr  0.01 sys +  0.34 cusr  0.01 csys =  0.39 CPU)
\&    Result: PASS
.Ve
.SH "Event Hooks"
.IX Header "Event Hooks"
There are various points in the test script where we might want to perform
some actions: Reset a test database, create a temp file, or otherwise set up
prerequisites for a test. \f(CW\*(C`Test::Class::Moose\*(C'\fR provides some hooks that allow
us to perform actions at these points.
.SS "test_startup / test_shutdown"
.IX Subsection "test_startup / test_shutdown"
\&\f(CW\*(C`test_startup\*(C'\fR is run as the very first thing in our test class, and is run only
once per test class. This allows us to set up some global things, like a
database that will be used throughout the entire test.
.PP
\&\f(CW\*(C`test_shutdown\*(C'\fR is run once as the very last thing in our test class, and is
run only once per test class. This allows us to clean up things from
\&\f(CW\*(C`test_startup\*(C'\fR, and also test to verify that anything from \f(CW\*(C`test_startup\*(C'\fR
looks exactly as it should before we clean it up.
.SS "test_setup / test_teardown"
.IX Subsection "test_setup / test_teardown"
What \f(CW\*(C`test_startup\*(C'\fR and \f(CW\*(C`test_shutdown\*(C'\fR are for the entire test class,
\&\f(CW\*(C`test_setup\*(C'\fR and \f(CW\*(C`test_teardown\*(C'\fR are for every single \f(CW\*(C`test_*\*(C'\fR method.
.PP
\&\f(CW\*(C`test_setup\*(C'\fR is run before every test method. For canonical unit testing,
this is where you can create the things you need for each test, such as a log
file, rebuilding fixtures, or starting a database transaction.
.PP
\&\f(CW\*(C`test_teardown\*(C'\fR happens after every test, and is where you can clean up the
things created in \f(CW\*(C`test_setup\*(C'\fR, such as ending the database transaction. Note
that some developers actually prefer their cleanup to happen in their
\&\f(CW\*(C`test_setup\*(C'\fR method, prior to setting up the test. That sounds odd, but it
means that if a test method fails, you haven't yet cleaned up and can easily
inspect your test environment.
.SH "Test Class Composition"
.IX Header "Test Class Composition"
The most important reason to choose a class test over a procedural test (using
only \f(CW\*(C`Test::More\*(C'\fR) is class composition.
.SS "Inheritance"
.IX Subsection "Inheritance"
Since we're using \f(CW\*(C`Moose\*(C'\fR, inheritance is as easy as:
.PP
.Vb 3
\&    package TestsFor::My::Test::Class;
\&    use Test::Class::Moose;
\&    extends \*(AqMy::Test::Base\*(Aq;
.Ve
.PP
\&\f(CW\*(C`Test::Class::Moose\*(C'\fR even provides a shortcut:
.PP
.Vb 2
\&    package TestsFor::My::Text::Class;
\&    use Test::Class::Moose extends => \*(AqMy::Test::Base\*(Aq;
.Ve
.PP
If \f(CW\*(C`My::Test::Base\*(C'\fR will not be testing anything itself, we do not put it in
\&\f(CW\*(C`t/lib/TestsFor\*(C'\fR, instead we put it in \f(CW\*(C`lib\*(C'\fR or \f(CW\*(C`t/lib\*(C'\fR (depending on if we
want it to be part of the public set of modules or not). This will make sure
our test runner does not try to run our base class that doesn't test anything
concrete.
.SS "Roles"
.IX Subsection "Roles"
If your distribution uses roles, so should your tests. Like inheritance, roles
are added in the regular \f(CW\*(C`Moose\*(C'\fR way:
.PP
.Vb 3
\&    package TestsFor::My::Test::Class;
\&    use Test::Class::Moose;
\&    with \*(AqMy::Test::Role\*(Aq;
.Ve
.PP
If you want your role to also provide tests, make sure you use
Test::Class::Moose::Role instead of \f(CW\*(C`Moose::Role\*(C'\fR.
.SS "Organizing Your Tests"
.IX Subsection "Organizing Your Tests"
Test code should be held to the same standard as the rest of the code in your
distribution:
.IP "Don't Repeat Yourself" 4
.IX Item "Don't Repeat Yourself"
Copy/paste code isn't okay in your module code, and it should not be okay in
your test code either! Refactor your tests to use roles or inheritance.
.SH "Advanced Features"
.IX Header "Advanced Features"
.SS "plan"
.IX Subsection "plan"
If you need to prepare a plan for your tests, you can do so using the \fIplan()\fR
method:
.PP
.Vb 5
\&    sub test_constructor {
\&        my $test = shift;
\&        $test\->test_report\->plan( 1 ); # 1 test in this sub
\&        isa_ok My::Module\->new, \*(AqMy::Module\*(Aq;
\&    }
.Ve
.PP
Using the \f(CW\*(C`plan()\*(C'\fR method, we can know exactly how many tests did not run if
the test method ends prematurely, or how many extra tests were run if we had
too many tests.
.PP
Alternately, you can use the \f(CW\*(C`Test\*(C'\fR (a single test) or \f(CW\*(C`Tests\*(C'\fR attributes
to set the plan. If you do this, the method is marked as a test method even if
it does not begin with \f(CW\*(C`test_\*(C'\fR.
.PP
.Vb 5
\&    # \*(AqTest\*(Aq asserts a plan of 1 test
\&    sub test_constructor : Test {
\&        my $test = shift;
\&        isa_ok My::Module\->new, \*(AqMy::Module\*(Aq;
\&    }
\&
\&    # \*(AqTests\*(Aq means multiple tests with no plan (note the test name)
\&    sub a_test_method : Tests {
\&        # many tests here
\&    }
\&
\&    # \*(AqTests($integer) means a plan of $integer
\&    sub this_is_another_test : Tests(3) {
\&        # 3 tests
\&    }
.Ve
.SS "skip"
.IX Subsection "skip"
We can use the \f(CW\*(C`test_startup\*(C'\fR and \f(CW\*(C`test_setup\*(C'\fR methods to skip tests that we
can't or don't want to run for whatever reason.
.PP
If we don't want to run a single test method, we can use the \f(CW\*(C`test_setup\*(C'\fR method
and call the \f(CW\*(C`test_skip\*(C'\fR method with the reason we're skipping the test.
.PP
.Vb 4
\&    sub test_will_fail {
\&        my ( $test ) = @_;
\&        fail "This doesn\*(Aqt work!";
\&    }
\&    
\&    sub test_setup {
\&        my $test = shift;
\&        if ( $test\->test_report\->current_method\->name eq \*(Aqtest_will_fail\*(Aq ) {
\&            $test\->test_skip( \*(AqIt doesn\*(Aqt work\*(Aq );
\&        }
\&    }
.Ve
.PP
If we don't want to run an entire class, we can use the \f(CW\*(C`test_startup\*(C'\fR method
and the same \f(CW\*(C`test_skip\*(C'\fR method with the reason we're skipping the test.
.PP
.Vb 4
\&    sub test_startup {
\&        my $test = shift;
\&        $test\->test_skip( "The entire class doesn\*(Aqt work" );
\&    }
.Ve
.SS "Run Specific Test Classes"
.IX Subsection "Run Specific Test Classes"
One of the problems with having only one test script to run all the test
classes is when we're working directly with one test class we still have to
run all the other test classes.
.PP
To fix this problem, \f(CW\*(C`Test::Class::Moose\*(C'\fR allows us to specify which specific
classes we want to run in its constructor:
.PP
.Vb 7
\&    # t/test_class_tests.t
\&    use File::Spec::Functions qw( catdir );
\&    use FindBin qw( $Bin );
\&    use Test::Class::Moose::Load catdir( $Bin, \*(Aqt\*(Aq, \*(Aqlib\*(Aq );
\&    Test::Class::Moose\->new(
\&        classes => [ \*(AqTestsFor::My::Test::Class\*(Aq ],
\&    )\->runtests;
.Ve
.PP
Now, we only run \f(CW\*(C`TestsFor::My::Test::Class\*(C'\fR instead of all the tests found in
\&\f(CW\*(C`TestsFor::\*(C'\fR.
.PP
This isn't very elegant though, since we have to edit \f(CW\*(C`t/test_class_tests.t\*(C'\fR
every time we want to run a new test. So, \f(CW\*(C`Test::Class::Moose\*(C'\fR can also
accept which test classes to run via \f(CW@ARGV\fR:
.PP
.Vb 5
\&    # t/test_class_tests.t
\&    use File::Spec::Functions qw( catdir );
\&    use FindBin qw( $Bin );
\&    use Test::Class::Moose::Load catdir( $Bin, \*(Aqt\*(Aq, \*(Aqlib\*(Aq );
\&    Test::Class::Moose\->new( classes => \e@ARGV )\->runtests;
.Ve
.PP
If \f(CW@ARGV\fR is empty, \f(CW\*(C`Test::Class::Moose\*(C'\fR will run all classes. To give
arguments while running \f(CW\*(C`prove\*(C'\fR, we use the arisdottle \f(CW\*(C`::\*(C'\fR:
.PP
.Vb 1
\&    prove \-lb t/test_class_tests.t :: My::Test::Class
.Ve
.PP
Now we can choose which test class we want to run right on the command line.
.SH "Tags"
.IX Header "Tags"
Tags are a way of organizing your test methods into groups. Later you can
choose to only execute the test methods from one or more tags. You can add
tags like \*(L"online\*(R" for tests that require a network, or \*(L"database\*(R" for tests
that require a database, and then include or exclude those tags when you
execute your tests.
.PP
You add tags to your test methods using attributes. A test method may have one
or more tags:
.PP
.Vb 2
\&    sub test_database : Tags( database )            { ... }
\&    sub test_network  : Tests(7) Tags( online api ) { ... }
.Ve
.PP
Then, if your database goes down, you can exclude those tests from the
\&\f(CW\*(C`t/test_class_tests.t\*(C'\fR script:
.PP
.Vb 8
\&    # t/test_class_tests.t
\&    use File::Spec::Functions qw( catdir );
\&    use FindBin qw( $Bin );
\&    use Test::Class::Moose::Load catdir( $Bin, \*(Aqt\*(Aq, \*(Aqlib\*(Aq );
\&    Test::Class::Moose\->new(
\&        classes      => \e@ARGV,
\&        exclude_tags => [qw( database )],
\&    )\->runtests;
.Ve
.PP
By adding tags to your tests, you can run only those tests that you
absolutely need to, increasing your productivity.
.SH "Boilerplate"
.IX Header "Boilerplate"
Here is the bare minimum you need to get started using \f(CW\*(C`Test::Class::Moose\*(C'\fR
.SS "Test Class"
.IX Subsection "Test Class"
.Vb 3
\&    # t/lib/TestsFor/My/Class.pm
\&    package TestsFor::My::Class;
\&    use Test::Class::Moose;
\&
\&    sub test_something {
\&        pass "I tested something!";
\&    }
\&
\&    1;
.Ve
.SS "Test Runner"
.IX Subsection "Test Runner"
.Vb 7
\&    # t/test_class_tests.t
\&    use File::Spec::Functions qw( catdir );
\&    use FindBin qw( $Bin );
\&    use Test::Class::Moose::Load catdir( $Bin, \*(Aqt\*(Aq, \*(Aqlib\*(Aq );
\&    Test::Class::Moose\->new(
\&        classes => \e@ARGV,
\&    )\->runtests;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Doug Bell: https://github.com/preaction
.SH "AUTHOR"
.IX Header "AUTHOR"
Curtis \*(L"Ovid\*(R" Poe <ovid@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2014 by Curtis \*(L"Ovid\*(R" Poe.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
