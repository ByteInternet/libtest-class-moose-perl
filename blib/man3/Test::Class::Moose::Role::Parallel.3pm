.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Class::Moose::Role::Parallel 3pm"
.TH Test::Class::Moose::Role::Parallel 3pm "2014-04-16" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Class::Moose::Role::Parallel \- run tests in parallel (highly experimental)
.SH "VERSION"
.IX Header "VERSION"
version 0.54
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package TestsFor::Some::Class;
\&    use Test::Class::Moose;
\&    with \*(AqTest::Class::Moose::Role::Parallel\*(Aq;
\&
\&    sub schedule {
\&       ...
\&       return \e@schedule;
\&    }
.Ve
.PP
And in your test driver:
.PP
.Vb 6
\&    my $test_suite = MyParallelTests\->new(
\&        show_timing => 0,
\&        jobs        => $jobs,
\&        statistics  => 1,
\&    );
\&    $test_suite\->runtests;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a very experimental role to add parallel testing to
\&\f(CW\*(C`Test::Class::Moose\*(C'\fR. The interface is subject to change and it probably
won't magically make your tests \fIsuccessfully\fR run in parallel unless you're
really lucky. If you've tried to parallelize your tests before, you understand
why: database tests don't use transactions, or some test munges global state,
and so on.
.PP
\&\fBImportant\fR: At the present time, attempting to run jobs in parallel means
that the \f(CW\*(C`Test::Class::Moose::test_report()\*(C'\fR method will not return anything
useful after the test suite is run, so don't try to call it afterwards. You
may still call it inside of a test class or test method as normal.
.PP
To use this role, simply include:
.PP
.Vb 3
\&    with qw(
\&        Test::Class::Moose::Role::Parallel
\&    );
.Ve
.PP
And in your driver script, the constructor takes a new argument, \f(CW\*(C`jobs\*(C'\fR.
.PP
.Vb 4
\&    my $test_suite = MyParallelTests\->new(
\&        jobs => $jobs,
\&    );
\&    $test_suite\->runtests;
.Ve
.PP
If the \f(CW\*(C`jobs\*(C'\fR is set to 1, then it's as if you've run things like normal.
However, if \f(CW\*(C`jobs\*(C'\fR is greater than 1, we'll fork off numerous jobs and run
the tests in parallel according to the schedule. If you have Sub::Attribute
installed, then all test methods tagged with \f(CW\*(C`noparallel\*(C'\fR will run
sequentially after the parallel tests:
.PP
.Vb 4
\&    sub test_destructive_code : Tags(noparallel) {
\&        my $test = shift;
\&        # run some tests here here that can\*(Aqt be run in parallel
\&    }
.Ve
.PP
If you need to write your own schedule, you can use the following naive
schedule as a template:
.PP
.Vb 5
\&    sub schedule {
\&        my $self   = shift;
\&        my $config = $self\->test_configuration;
\&        my $jobs   = $config\->jobs;
\&        my @schedule;
\&
\&        my $current_job = 0;
\&        foreach my $test_class ( $self\->test_classes ) {
\&            my $test_instance = $test_class\->new( $config\->args );
\&            foreach my $method ( $test_instance\->test_methods ) {
\&                $schedule[$current_job] ||= {};
\&
\&                # assign a method for a class to a given job
\&                $schedule[$current_job]{$test_class}{$method} = 1;
\&                $current_job++;
\&                $current_job = 0 if $current_job >= $jobs;
\&            }
\&        }
\&        unshift @schedule => undef; # we have no sequential jobs
\&        return @schedule;
\&    }
.Ve
.PP
Each job in the schedule is a hashref. The keys are the names of classes for
that job and the values are a hashref. The keys of the latter hashref are
methods for that class for that job and their values \fBmust\fR be true. For
example, a single job with two classes and six methods (3 per class) may look
like this:
.PP
.Vb 12
\&    {
\&        \*(AqTestsFor::Person\*(Aq => {
\&            test_name => 1,
\&            test_age  => 1,
\&            test_ssn  => 1,
\&        },
\&        \*(AqTestsFor::Person::Employee\*(Aq => {
\&            test_employee_number => 1,
\&            test_manager         => 1,
\&            test_name            => 1,
\&        },
\&    }
.Ve
.PP
Note that a class may be spread over multiple jobs. That's perfectly fine.
This is an example of a complete schedule from the test suite, spread across
two jobs:
.PP
.Vb 10
\&    @schedule = (
\&      undef,                              # no sequential tests
\&      {                                   # first job
\&        \*(AqTestsFor::Alpha\*(Aq => {
\&          test_alpha_first => 1
\&        },
\&        \*(AqTestsFor::Alpha::Subclass\*(Aq => {
\&          test_alpha_first => 1,
\&          test_second      => 1
\&        },
\&        \*(AqTestsFor::Beta\*(Aq => {
\&          test_second => 1
\&        }
\&      },
\&      {                                   # second job
\&        \*(AqTestsFor::Alpha\*(Aq => {
\&          test_second => 1
\&        },
\&        \*(AqTestsFor::Alpha::Subclass\*(Aq => {
\&          test_another => 1
\&        },
\&        \*(AqTestsFor::Beta\*(Aq => {
\&          test_beta_first => 1
\&        }
\&      }
\&    );
.Ve
.PP
If the first \*(L"job\*(R" listed in the schedule it not undef, it will be considered
to be tests that must be run sequentially after all other tests have finished
running in parallel. This is for tests methods which, for whatever reason,
cannot run in parallel.
.PP
In other words, the \f(CW@schedule\fR returned looks like this if you request four
jobs:
.PP
.Vb 7
\&    my @schedule = (
\&        \e%jobs_to_run_sequentially_after_parallel_tests,
\&        \e%classes_and_their_methods_for_job_1,
\&        \e%classes_and_their_methods_for_job_2,
\&        \e%classes_and_their_methods_for_job_3,
\&        \e%classes_and_their_methods_for_job_4,
\&    );
.Ve
.SH "CREATING YOUR OWN SCHEDULE"
.IX Header "CREATING YOUR OWN SCHEDULE"
You may wish to create your own \f(CW\*(C`schedule()\*(C'\fR method, using the above above as
a guideline. It naively walks your classes and their methods and distributes
them evenly across your jobs. That probably won't work for you. For example,
it's possible that you'll wind up accidentally grouping long-running test
methods in a single job when you want them in separate jobs. Use the \f(CW\*(C`$test_suite\->test_report\*(C'\fR \fIwithout\fR running the tests in parallel to
determine which classes and methods take longer to run, save this information
and then use that to build an effective schedule.
.PP
Another reason the naive approach won't work is because you probably have
tests that don't run in parallel (for example, they munge global state or
they drop and recreate a database). You'll need to use your \f(CW\*(C`schedule()\*(C'\fR to
add them to the job listed in \f(CW$schedule[0]\fR. However, if you have
Sub::Attribute installed, you can use the \f(CW\*(C`noparallel\*(C'\fR tag to mark tests
that must not be run in parallel:
.PP
.Vb 4
\&    sub test_database_migrations : Tags(noparallel) {
\&        my $test = shift;
\&        # potentially destructive tests here
\&    }
.Ve
.PP
Of course, if you provide your own schedule, you'll need to account for the
\&\f(CW\*(C`noparallel\*(C'\fR tag yourself, or use something else.
.PP
Or it could be that some tests run in parallel with some tests, but not
others. Again, your schedule needs to be written to take that into account.
.PP
To manage this information better, if you can use tags, you'll find that
\&\f(CW\*(C`Test::Class::Moose::AttributeRegistry\*(C'\fR can help:
.PP
.Vb 1
\&    use aliased \*(AqTest::Class::Moose::AttributeRegistry\*(Aq;
\&
\&    if ( AttributeRegistry\->method_has_tag( $class, $method, $tag ) ) {
\&
\&        # put the method in the appropriate job
\&    }
.Ve
.SH "INTERNALS"
.IX Header "INTERNALS"
This is all subject to wild change, but surprisingly, we didn't have to do any
monkey-patching of code. It works like this:
.PP
We use \f(CW\*(C`Parallel::ForkManager\*(C'\fR to create our jobs.
.PP
For each job, we grab the schedule for that job number and the \f(CW\*(C`test_classes\*(C'\fR
and \f(CW\*(C`test_methods\*(C'\fR methods only return classes and methods in the current job
schedule. Then we run only those tests, but capture the output like this:
.PP
.Vb 1
\&    my $builder = Test::Builder\->new;
\&
\&    my $output;
\&    $builder\->output( \e$output );
\&    $builder\->failure_output( \e$output );
\&    $builder\->todo_output( \e$output );
\&
\&    $self\->runtests;
\&
\&    # $output contains the TAP
.Ve
.PP
Afterwards, if there are any sequential tests, we run them using the above
procedure.
.PP
All output is assembled using the experimental TAP::Stream module bundled
with this one. If it works, we may break it into a separate distribution
later. That module allows you to combine multiple \s-1TAP\s0 streams into a single
stream using subtests.
.PP
Then we simply print the resulting combined \s-1TAP\s0 to the current
Test::Builder output handle (defaults to \s-1STDOUT\s0) and \f(CW\*(C`prove\*(C'\fR can read the
output as usual.
.PP
Note that because we're merging the regular output, failure output, and \s-1TODO\s0
output into a single stream, there could be side effects if your failure
output or \s-1TODO\s0 output resembles \s-1TAP\s0 (and doesn't have a leading '#' mark to
indicate that it should be ignored).
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
For our \f(CW\*(C`t/parallellib\*(C'\fR test suite, we go from 11 seconds on a regular test
run down to 2 seconds when running with 8 jobs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Curtis \*(L"Ovid\*(R" Poe <ovid@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2014 by Curtis \*(L"Ovid\*(R" Poe.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
