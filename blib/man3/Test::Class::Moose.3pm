.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Class::Moose 3pm"
.TH Test::Class::Moose 3pm "2014-03-18" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Class::Moose \- Serious testing for serious Perl
.SH "VERSION"
.IX Header "VERSION"
version 0.54
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    package TestsFor::DateTime;
\&    use Test::Class::Moose;
\&    use DateTime;
\&
\&    # methods that begin with test_ are test methods.
\&    sub test_constructor {
\&        my $test = shift;
\&        $test\->test_report\->plan(3);    # strictly optional
\&
\&        can_ok \*(AqDateTime\*(Aq, \*(Aqnew\*(Aq;
\&        my %args = (
\&            year  => 1967,
\&            month => 6,
\&            day   => 20,
\&        );
\&        isa_ok my $date = DateTime\->new(%args), \*(AqDateTime\*(Aq;
\&        is $date\->year, $args{year}, \*(Aq... and the year should be correct\*(Aq;
\&    }
\&
\&    1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
See Test::Class::Moose hompage <http://ovid.github.io/test-class-moose/> for
a summary.
.PP
`Test::Class::Moose` is a powerful testing framework for Perl. Out of the box
you get:
.IP "\(bu" 4
Reporting
.IP "\(bu" 4
Extensibility
.IP "\(bu" 4
Tagging tests
.IP "\(bu" 4
Parallel testing
.IP "\(bu" 4
Test inheritance
.IP "\(bu" 4
Write your tests using Moose
.IP "\(bu" 4
All the testing functions and behavior from Test::Most
.IP "\(bu" 4
Event handlers for startup, setup, teardown, and shutdown of test classes
.PP
Better docs will come later. You should already know how to use Moose and
Test::Class.
.SH "BASICS"
.IX Header "BASICS"
.SS "Inheriting from Test::Class::Moose"
.IX Subsection "Inheriting from Test::Class::Moose"
Just \f(CW\*(C`use Test::Class::Moose\*(C'\fR. That's all. You'll get all Test::Most test
functions, too, along with \f(CW\*(C`strict\*(C'\fR and \f(CW\*(C`warnings\*(C'\fR. You can use all Moose
behavior, too.
.SS "Declare a test method"
.IX Subsection "Declare a test method"
All method names that begin with \f(CW\*(C`test_\*(C'\fR are test methods. Methods that do
not are not test methods.
.PP
.Vb 2
\& sub test_this_is_a_method {
\&     my $test = shift;
\&
\&     $test\->this_is_not_a_test_method;
\&     ok 1, \*(Aqwhee!\*(Aq;
\& }
\&
\& sub this_is_not_a_test_method {
\&    my $test = shift;
\&    # but you can, of course, call it like normal
\& }
.Ve
.PP
You may specify \f(CW\*(C`Test\*(C'\fR and \f(CW\*(C`Tests\*(C'\fR method attributes, just like in
Test::Class and the method will automatically be a test method, even if
does not start with \f(CW\*(C`test_\*(C'\fR:
.PP
.Vb 3
\&    sub this_is_a_test : Test {
\&        pass \*(Aqwe have a single test\*(Aq;
\&    }
\&
\&    sub another_test_method : Tests { # like "no_plan"
\&        # a bunch of tests
\&    }
\&
\&    sub yet_another_test_method : Tests(7) { # sets plan to 7 tests
\&        ...
\&    }
.Ve
.PP
\&\fBNote\fR: Prior to version 0.51, this feature only worked if you had the
optional \f(CW\*(C`Sub::Attribute\*(C'\fR installed.
.SS "Plans"
.IX Subsection "Plans"
No plans needed. The test suite declares a plan of the number of test classes.
.PP
Each test class is a subtest declaring a plan of the number of test methods.
.PP
Each test method relies on an implicit \f(CW\*(C`done_testing\*(C'\fR call.
.PP
If you prefer, you can declare a plan in a test method:
.PP
.Vb 5
\&    sub test_something {
\&        my $test = shift;
\&        $test\->test_report\->plan($num_tests);
\&        ...
\&    }
.Ve
.PP
Or with a \f(CW\*(C`Tests\*(C'\fR attribute:
.PP
.Vb 4
\&    sub test_something : Tests(3) {
\&        my $test = shift;
\&        ...
\&    }
.Ve
.PP
You may call \f(CW\*(C`plan()\*(C'\fR multiple times for a given test method. Each call to
\&\f(CW\*(C`plan()\*(C'\fR will add that number of tests to the plan.  For example, with a
method modifier:
.PP
.Vb 3
\&    before \*(Aqtest_something\*(Aq => sub {
\&        my $test = shift;
\&        $test\->test_report\->plan($num_extra_tests);
\&
\&        # more tests
\&    };
.Ve
.PP
Please note that if you call \f(CW\*(C`plan\*(C'\fR, the plan will still show up at the end
of the subtest run, but you'll get the desired failure if the number of tests
run does not match the plan.
.SS "Inheriting from another Test::Class::Moose class"
.IX Subsection "Inheriting from another Test::Class::Moose class"
List it as the \f(CW\*(C`extends\*(C'\fR in the import list.
.PP
.Vb 2
\& package TestsFor::Some::Class::Subclass;
\& use Test::Class::Moose extends => \*(AqTestsFor::Some::Class\*(Aq;
\&
\& sub test_me {
\&     my $test  = shift;
\&     my $class = $test\->test_class;
\&     ok 1, "I overrode my parent! ($class)";
\& }
\&
\& before \*(Aqtest_this_baby\*(Aq => sub {
\&     my $test  = shift;
\&     my $class = $test\->test_class;
\&     pass "This should run before my parent method ($class)";
\& };
\&
\& sub this_should_not_run {
\&     my $test = shift;
\&     fail "We should never see this test";
\& }
\&
\& sub test_this_should_be_run {
\&     for ( 1 .. 5 ) {
\&         pass "This is test number $_ in this method";
\&     }
\& }
\&
\& 1;
.Ve
.SH "TEST CONTROL METHODS"
.IX Header "TEST CONTROL METHODS"
Do not run tests in test control methods. This will cause the test control
method to fail (this is a feature, not a bug).  If a test control method
fails, the class/method will fail and testing for that class should stop.
.PP
\&\fBEvery\fR test control method will be passed two arguments. The first is the
\&\f(CW$test\fR invocant. The second is an object implementing
Test::Class::Moose::Role::Reporting. You may find that the \f(CW\*(C`notes\*(C'\fR hashref
is a handy way of recording information you later wish to use if you call \f(CW\*(C`$test_suite\->test_report\*(C'\fR.
.PP
These are:
.IP "\(bu" 4
\&\f(CW\*(C`test_startup\*(C'\fR
.Sp
.Vb 5
\& sub test_startup {
\&    my $test = shift;
\&    $test\->next::method;
\&    # more startup
\& }
.Ve
.Sp
Runs at the start of each test class. If you need to know the name of the
class you're running this in (though usually you shouldn't), use
\&\f(CW\*(C`$test\->test_class\*(C'\fR, or you can do this:
.Sp
.Vb 7
\&    sub test_startup {
\&        my $test                 = shift;
\&        my $report               = $test\->test_report;
\&        my $class                = $report\->current_class\->name;
\&        my $upcoming_test_method = $report\->current_method\->name;
\&        ...
\&    }
.Ve
.Sp
The \f(CW\*(C`$test\->test_report\*(C'\fR object is a Test::Class::Moose::Report::Class
object.
.IP "\(bu" 4
\&\f(CW\*(C`test_setup\*(C'\fR
.Sp
.Vb 5
\& sub test_setup {
\&    my $test = shift;
\&    $test\->next::method;
\&    # more setup
\& }
.Ve
.Sp
Runs at the start of each test method. If you must know the name of the test
you're about to run, you can do this:
.Sp
.Vb 6
\& sub test_setup {
\&    my $test = shift;
\&    $test\->next::method;
\&    my $test_method = $test\->test_report\->current_method\->name;
\&    # do something with it
\& }
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`test_teardown\*(C'\fR
.Sp
.Vb 5
\& sub test_teardown {
\&    my $test = shift;
\&    # more teardown
\&    $test\->next::method;
\& }
.Ve
.Sp
Runs at the end of each test method.
.IP "\(bu" 4
\&\f(CW\*(C`test_shutdown\*(C'\fR
.Sp
.Vb 5
\& sub test_shutdown {
\&     my $test = shift;
\&     # more teardown
\&     $test\->next::method;
\& }
.Ve
.Sp
Runs at the end of each test class.
.PP
To override a test control method, just remember that this is \s-1OO:\s0
.PP
.Vb 5
\& sub test_setup {
\&     my $test = shift;
\&     $test\->next::method; # optional to call parent test_setup
\&     # more setup code here
\& }
.Ve
.SH "RUNNING THE TEST SUITE"
.IX Header "RUNNING THE TEST SUITE"
We \fIstrongly\fR recommend using Test::Class::Moose::Load as the driver for
your test suite. Simply point it at the directory or directories containing
your test classes:
.PP
.Vb 2
\& use Test::Class::Moose::Load \*(Aqt/lib\*(Aq;
\& My::Base::Class\->new\->runtests;
.Ve
.PP
By running \f(CW\*(C`Test::Class::Moose\*(C'\fR with a single driver script like this, all
classes are loaded once and this can be a significant performance boost. This
does mean a global state will be shared, so keep this in mind.
.PP
You can also pass arguments to \f(CW\*(C`Test::Class::Moose\*(C'\fR's contructor.
.PP
.Vb 7
\& my $test_suite = My::Base::Class\->new({
\&     show_timing => 1,
\&     randomize   => 0,
\&     statistics  => 1,
\& });
\& # do something
\& $test_suite\->runtests;
.Ve
.PP
The attributes passed in the constructor are not directly available from the
Test::Class::Moose instance. They're available in
Test::Class::Moose::Config and to avoid namespace pollution, we do \fInot\fR
delegate the attributes directly as a result. If you need them at runtime,
you'll need to access the \f(CW\*(C`test_configuration\*(C'\fR attribute:
.PP
.Vb 1
\& my $builder = $test_suite\->test_configuration\->builder;
.Ve
.PP
Note that you can call \f(CW\*(C`Test::Class::Moose\->new\*(C'\fR instead of 
\&\f(CW\*(C`My::Base::Class\->new\*(C'\fR, but we recommend that you instantiate an instance
of your base class instead of \f(CW\*(C`Test::Class::Moose\*(C'\fR. There are times when you
may apply a role to your base class and modify it, but running it in the
context of \f(CW\*(C`Test::Class::Moose\*(C'\fR will not always pick up those modifications.
.PP
In other words, create an instance of your base class, not
\&\f(CW\*(C`Test::Class::Moose\*(C'\fR.
.SS "Contructor Attributes"
.IX Subsection "Contructor Attributes"
.IP "\(bu" 4
\&\f(CW\*(C`show_timing\*(C'\fR
.Sp
Boolean. Will display verbose information on the amount of time it takes each
test class/test method to run. Defaults to false, but see \f(CW\*(C`use_environment\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`statistics\*(C'\fR
.Sp
Boolean. Will display number of classes, test methods and tests run. Defaults
to false, but see \f(CW\*(C`use_environment\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`use_environment\*(C'\fR
.Sp
If this is true, then the default value for show_timing and statistics will be
true if the \f(CW\*(C`HARNESS_IS_VERBOSE\*(C'\fR environment variable is true. This is set
when running \f(CW\*(C`prove \-v ...\*(C'\fR, for example.
.IP "\(bu" 4
\&\f(CW\*(C`randomize\*(C'\fR
.Sp
Boolean. Will run test methods in a random order.
.IP "\(bu" 4
\&\f(CW\*(C`builder\*(C'\fR
.Sp
Defaults to \f(CW\*(C`Test::Builder\->new\*(C'\fR. You can supply your own builder if you
want, but it must conform to the Test::Builder interface. We make no
guarantees about which part of the interface it needs.
.IP "\(bu" 4
\&\f(CW\*(C`test_classes\*(C'\fR
.Sp
Takes a class name or an array reference of class names. If it is present,
only these test classes will be run. This is very useful if you wish to run an
individual class as a test:
.Sp
.Vb 3
\&    My::Base::Class\->new(
\&        test_classes => $ENV{TEST_CLASS}, # ignored if undef
\&    )\->runtests;
.Ve
.Sp
You can also achieve this effect by writing a subclass and overriding the
\&\f(CW\*(C`test_classes\*(C'\fR method, but this makes it trivial to do this:
.Sp
.Vb 1
\&    TEST_CLASS=TestsFor::Our::Company::Invoice prove \-lv t/test_classes.t
.Ve
.Sp
Alternatively:
.Sp
.Vb 3
\&    My::Base::Class\->new(
\&        test_classes => \e@ARGV, # ignored if empty
\&    )\->runtests;
.Ve
.Sp
That lets you use the arisdottle to provide arguments to your test driver
script:
.Sp
.Vb 1
\&    prove \-lv t/test_classes.t :: TestsFor::Our::Company::Invoice TestsFor::Something::Else
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`include\*(C'\fR
.Sp
Regex. If present, only test methods whose name matches \f(CW\*(C`include\*(C'\fR will be
included. \fBHowever\fR, they must still start with \f(CW\*(C`test_\*(C'\fR.
.Sp
For example:
.Sp
.Vb 3
\& my $test_suite = Test::Class::Moose\->new({
\&     include => qr/customer/,
\& });
.Ve
.Sp
The above constructor will let you match test methods named \f(CW\*(C`test_customer\*(C'\fR
and \f(CW\*(C`test_customer_account\*(C'\fR, but will not suddenly match a method named
\&\f(CW\*(C`default_customer\*(C'\fR.
.Sp
By enforcing the leading \f(CW\*(C`test_\*(C'\fR behavior, we don't surprise developers who
are trying to figure out why \f(CW\*(C`default_customer\*(C'\fR is being run as a test. This
means an \f(CW\*(C`include\*(C'\fR such as \f(CW\*(C`/^customer.*/\*(C'\fR will never run any tests.
.IP "\(bu" 4
\&\f(CW\*(C`exclude\*(C'\fR
.Sp
Regex. If present, only test methods whose names don't match \f(CW\*(C`exclude\*(C'\fR will be
included. \fBHowever\fR, they must still start with \f(CW\*(C`test_\*(C'\fR. See \f(CW\*(C`include\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`include_tags\*(C'\fR
.Sp
Array ref of strings matching method tags (a single string is also ok). If
present, only test methods whose tags match \f(CW\*(C`include_tags\*(C'\fR or whose tags
don't match \f(CW\*(C`exclude_tags\*(C'\fR will be included. \fBHowever\fR, they must still
start with \f(CW\*(C`test_\*(C'\fR.
.Sp
For example:
.Sp
.Vb 3
\& my $test_suite = Test::Class::Moose\->new({
\&     include_tags => [qw/api database/],
\& });
.Ve
.Sp
The above constructor will only run tests tagged with \f(CW\*(C`api\*(C'\fR or \f(CW\*(C`database\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`exclude_tags\*(C'\fR
.Sp
The same as \f(CW\*(C`include_tags\*(C'\fR, but will exclude the tests rather than include
them. For example, if your network is down:
.Sp
.Vb 3
\& my $test_suite = Test::Class::Moose\->new({
\&     exclude_tags => [ \*(Aqnetwork\*(Aq ],
\& });
\&
\& # or
\& my $test_suite = Test::Class::Moose\->new({
\&     exclude_tags => \*(Aqnetwork\*(Aq,
\& });
.Ve
.SS "Skipping Classes and Methods"
.IX Subsection "Skipping Classes and Methods"
If you wish to skip a class, set the reason in the \f(CW\*(C`test_startup\*(C'\fR method.
.PP
.Vb 4
\&    sub test_startup {
\&        my $test = shift;
\&        $test\->test_skip("I don\*(Aqt want to run this class");
\&    }
.Ve
.PP
If you wish to skip an individual method, do so in the \f(CW\*(C`test_setup\*(C'\fR method.
.PP
.Vb 3
\&    sub test_setup {
\&        my $test = shift;
\&        my $test_method = $test\->test_report\->current_method;
\&    
\&        if ( \*(Aqtest_time_travel\*(Aq eq $test_method\->name ) {
\&            $test\->test_skip("Time travel not yet available");
\&        }
\&    }
.Ve
.ie n .SS "The ""Tests"" and ""Test"" Attributes"
.el .SS "The ``Tests'' and ``Test'' Attributes"
.IX Subsection "The Tests and Test Attributes"
If you're comfortable with Test::Class, know test methods methods are
declared in Test::Class with \f(CW\*(C`Test\*(C'\fR (for a method with a single test) or
\&\f(CW\*(C`Tests\*(C'\fR, for a method with multiple tests. This also works for
\&\f(CW\*(C`Test::Class::Moose\*(C'\fR. Test methods declared this way do not need to start
with \f(CW\*(C`test_\*(C'\fR.
.PP
.Vb 3
\&    sub something_we_want_to_check : Test {
\&        # this method may have only one test
\&    }
\&
\&    sub something_else_to_check : Tests {
\&        # this method may have multiple tests
\&    }
\&
\&    sub another_test_method : Tests(3) {
\&        # this method must have exactly 3 tests
\&    }
.Ve
.PP
If a test method overrides a parent test method and calls it, their plans will
be added together:
.PP
.Vb 1
\&    package TestsFor::Parent;
\&
\&    use Test::Class::Moose;
\&
\&    sub some_test : Tests(3) {
\&        # three tests
\&    }
.Ve
.PP
And later:
.PP
.Vb 1
\&    package TestsFor::Child;
\&
\&    use Test::Class::Moose extends => \*(AqTestsFor::Parent\*(Aq;
\&
\&    sub some_test : Tests(2) {
\&        my $test = shift;
\&        $test\->next::method;
\&        # 2 tests here
\&    }
.Ve
.PP
In the above example, \f(CW\*(C`TestsFor::Parent::some_test\*(C'\fR will run three tests, but
\&\f(CW\*(C`TestsFor::Child::some_test\*(C'\fR will run \fIfive\fR tests (two tests, plus the
three from the parent).
.PP
Note that if a plan is explicitly declared, any modifiers or overriding
methods calling the original method will also have to assert the number of
tests to ensure the plan is correct. The above \f(CW\*(C`TestsFor::Parent\*(C'\fR and
\&\f(CW\*(C`TestsFor::Child\*(C'\fR code would fail if the child's \f(CW\*(C`some_test\*(C'\fR method
attribute was \f(CW\*(C`Tests\*(C'\fR without the number of tests asserted.
.PP
Do not use \f(CW\*(C`Test\*(C'\fR or \f(CW\*(C`Tests\*(C'\fR with test control methods becase you don't run
tests in those.
.SS "Tagging Methods"
.IX Subsection "Tagging Methods"
Sometimes you want to be able to assign metadata to help you better manage
your test suite. You can do this with tags:
.PP
.Vb 3
\&    sub test_save_poll_data : Tags(api network) {
\&        ...
\&    }
.Ve
.PP
Tags are strictly optional and you can provide one or more tags for each test
method with a space separated list of tags. You can use this to filter your
tests suite, if desired. For example, if your network goes down and all tests
which rely on a network are tagged with \f(CW\*(C`network\*(C'\fR, you can skip those tests
with this:
.PP
.Vb 1
\&    My::Base::Class\->new( exclude_tags => \*(Aqnetwork\*(Aq )\->runtests;
.Ve
.PP
Or maybe you want to run all \f(CW\*(C`api\*(C'\fR and \f(CW\*(C`database\*(C'\fR tests, but skip those
marked \f(CW\*(C`deprecated\*(C'\fR:
.PP
.Vb 4
\&    My::Base::Class\->new(
\&        include_tags => [qw/api database/],
\&        exclude_tags => \*(Aqdeprecated\*(Aq,
\&    )\->runtests;
.Ve
.PP
You can also inspect tags withing your test classes:
.PP
.Vb 7
\&    sub test_setup {
\&        my $test          = shift;
\&        my $method_to_run = $test\->test_report\->current_method;
\&        if ( $method_to_run\->has_tag(\*(Aqdb\*(Aq) ) {
\&            $test\->load_database_fixtures;
\&        }
\&    }
.Ve
.PP
Tagging support relies on Sub::Attribute. If this module is not available,
\&\f(CW\*(C`include_tags\*(C'\fR and \f(CW\*(C`exclude_tags\*(C'\fR will be ignored, but a warning will be
issued if those are seen. Prior to version 0.51, \f(CW\*(C`Sub::Attribute\*(C'\fR was
optional. Now it's mandatory, so those features should always work.
.SH "PARALLEL TESTING"
.IX Header "PARALLEL TESTING"
If you want to run the tests in parallel, see the experimental
\&\f(CW\*(C`Test::Class::Moose::Role::Parallel\*(C'\fR role. Read the documentation carefully
as it can take a while to understand. You only need to use the role and
(optionally) provide a \f(CW\*(C`schedule()\*(C'\fR method. Any tests tagged with
\&\f(CW\*(C`noparallel\*(C'\fR will be run sequentially after the parallel tests (unless you
provide your own schedule, in which case you can do anything you want).
.SH "THINGS YOU CAN OVERRIDE"
.IX Header "THINGS YOU CAN OVERRIDE"
\&... but probably shouldn't.
.PP
As a general rule, methods beginning with \f(CW\*(C`/^test_/\*(C'\fR are reserved for
Test::Class::Moose. This makes it easier to remember what you can and
cannot override. However, any test with \f(CW\*(C`Test\*(C'\fR or \f(CW\*(C`Tests\*(C'\fR are test methods
regardless of their names.
.ie n .SS """test_configuration"""
.el .SS "\f(CWtest_configuration\fP"
.IX Subsection "test_configuration"
.Vb 1
\& my $test_configuration = $test\->test_configuration;
.Ve
.PP
Returns the Test::Class::Moose::Config object.
.ie n .SS """test_report"""
.el .SS "\f(CWtest_report\fP"
.IX Subsection "test_report"
.Vb 1
\& my $report = $test\->test_report;
.Ve
.PP
Returns the Test::Class::Moose::Report object. Useful if you want to do
your own reporting and not rely on the default output provided with the
\&\f(CW\*(C`statistics\*(C'\fR boolean option.
.PP
You can also call it in test classes (most useful in the \f(CW\*(C`test_setup()\*(C'\fR method):
.PP
.Vb 10
\&    sub test_setup {
\&        my $test = shift;
\&        $self\->next::method;
\&        my $report= $test\->test_report;
\&        my $class = $test\->current_class;
\&        my $method = $test\->current_method; # the test method we\*(Aqre about to run
\&        if ( $method\->name =~ /customer/ ) {
\&            $test\->load_customer_fixture;
\&        }
\&        # or better still
\&        if ( $method\->has_tag(\*(Aqcustomer\*(Aq) ) {
\&            $test\->load_customer_fixture;
\&        }
\&    }
.Ve
.ie n .SS """test_class"""
.el .SS "\f(CWtest_class\fP"
.IX Subsection "test_class"
.Vb 1
\& my $class = $test\->test_class;
.Ve
.PP
Returns the name for this test class. Useful if you rebless an object (such as
applying a role at runtime) and don't want to lose the original class name.
.ie n .SS """test_classes"""
.el .SS "\f(CWtest_classes\fP"
.IX Subsection "test_classes"
You may override this in a subclass. Currently returns a sorted list of all
loaded classes that inherit directly or indirectly through
Test::Class::Moose
.ie n .SS """test_methods"""
.el .SS "\f(CWtest_methods\fP"
.IX Subsection "test_methods"
You may override this in a subclass. Currently returns all methods in a test
class that start with \f(CW\*(C`test_\*(C'\fR (except for the test control methods).
.PP
Please note that the behavior for \f(CW\*(C`include\*(C'\fR and \f(CW\*(C`exclude\*(C'\fR is also contained
in this method. If you override it, you will need to account for those
yourself.
.ie n .SS """runtests"""
.el .SS "\f(CWruntests\fP"
.IX Subsection "runtests"
If you really, really want to change how this module works, you can override
the \f(CW\*(C`runtests\*(C'\fR method. We don't recommend it.
.PP
Returns the Test::Class::Moose instance.
.ie n .SS """import"""
.el .SS "\f(CWimport\fP"
.IX Subsection "import"
Sadly, we have an \f(CW\*(C`import\*(C'\fR method. This is used to automatically provide you
with all of the Test::Most behavior.
.SH "SAMPLE TAP OUTPUT"
.IX Header "SAMPLE TAP OUTPUT"
We use nested tests (subtests) at each level:
.PP
.Vb 10
\&    1..2
\&    # 
\&    # Executing tests for TestsFor::Basic::Subclass
\&    # 
\&        1..3
\&        # TestsFor::Basic::Subclass\->test_me()
\&            ok 1 \- I overrode my parent! (TestsFor::Basic::Subclass)
\&            1..1
\&        ok 1 \- test_me
\&        # TestsFor::Basic::Subclass\->test_this_baby()
\&            ok 1 \- This should run before my parent method (TestsFor::Basic::Subclass)
\&            ok 2 \- whee! (TestsFor::Basic::Subclass)
\&            1..2
\&        ok 2 \- test_this_baby
\&        # TestsFor::Basic::Subclass\->test_this_should_be_run()
\&            ok 1 \- This is test number 1 in this method
\&            ok 2 \- This is test number 2 in this method
\&            ok 3 \- This is test number 3 in this method
\&            ok 4 \- This is test number 4 in this method
\&            ok 5 \- This is test number 5 in this method
\&            1..5
\&        ok 3 \- test_this_should_be_run
\&    ok 1 \- TestsFor::Basic::Subclass
\&    # 
\&    # Executing tests for TestsFor::Basic
\&    # 
\&        1..2
\&        # TestsFor::Basic\->test_me()
\&            ok 1 \- test_me() ran (TestsFor::Basic)
\&            ok 2 \- this is another test (TestsFor::Basic)
\&            1..2
\&        ok 1 \- test_me
\&        # TestsFor::Basic\->test_this_baby()
\&            ok 1 \- whee! (TestsFor::Basic)
\&            1..1
\&        ok 2 \- test_this_baby
\&    ok 2 \- TestsFor::Basic
\&    # Test classes:    2
\&    # Test methods:    5
\&    # Total tests run: 11
\&    ok
\&    All tests successful.
\&    Files=1, Tests=2,  2 wallclock secs ( 0.03 usr  0.00 sys +  0.27 cusr  0.01 csys =  0.31 CPU)
\&    Result: PASS
.Ve
.SH "REPORTING"
.IX Header "REPORTING"
See Test::Class::Moose::Report for more detailed information on reporting.
.PP
Reporting features are subject to change.
.PP
Sometimes you want more information about your test classes, it's time to do
some reporting. Maybe you even want some tests for your reporting. If you do
that, run the test suite in a subtest (because the plans will otherwise be
wrong).
.PP
.Vb 5
\&    #!/usr/bin/env perl
\&    use lib \*(Aqlib\*(Aq;
\&    use Test::Most;
\&    use Test::Class::Moose::Load qw(t/lib);
\&    my $test_suite = My::Base::Class\->new;
\&
\&    subtest \*(Aqrun the test suite\*(Aq => sub {
\&        $test_suite\->runtests;
\&    };
\&    my $report = $test_suite\->test_report;
\&
\&    foreach my $class ( $report\->all_test_classes ) {
\&        my $class_name = $class\->name;
\&        ok !$class\->is_skipped, "$class_name was not skipped";
\&
\&        subtest "$class_name methods" => sub {
\&            foreach my $method ( $class\->all_test_methods ) {
\&                my $method_name = $method\->name;
\&                ok !$method\->is_skipped, "$method_name was not skipped";
\&                cmp_ok $method\->num_tests, \*(Aq>\*(Aq, 0,
\&                  \*(Aq... and some tests should have been run\*(Aq;
\&                diag "Run time for $method_name: ".$method\->time\->duration;
\&            }
\&        };
\&        my $time   = $class\->time;
\&        diag "Run time for $class_name: ".$class\->time\->duration;
\&
\&        my $real   = $time\->real;
\&        my $user   = $time\->user;
\&        my $system = $time\->system;
\&        # do with these as you will
\&    }
\&    diag "Number of test classes: " . $report\->num_test_classes;
\&    diag "Number of test methods: " . $report\->num_test_methods;
\&    diag "Number of tests:        " . $report\->num_tests;
\&
\&    done_testing;
.Ve
.PP
If you just want to output reporting information, you do not need to run the
test suite in a subtest:
.PP
.Vb 3
\&    my $test_suite = My::Base::Class\->new\->runtests;
\&    my $report     = $test_suite\->test_report;
\&    ...
.Ve
.PP
Or even shorter:
.PP
.Vb 1
\&    my $report = My::Base::Class\->new\->runtests\->test_report;
.Ve
.SH "EXTRAS"
.IX Header "EXTRAS"
If you would like Test::Class::Moose to take care of loading your classes
for you, see Test::Class::Moose::Role::AutoUse in this distribution.
.SH "DEPRECATIONS"
.IX Header "DEPRECATIONS"
.IP "\(bu" 4
\&\f(CW\*(C`test_reporting\*(C'\fR
.Sp
As of version .40, the long deprecated method \f(CW\*(C`test_reporting\*(C'\fR has now been
removed.
.IP "\(bu" 4
\&\f(CW$report\fR argument to methods deprecated
.Sp
Prior to version .40, you used to have a second argument to all test methods
and test control methods:
.Sp
.Vb 4
\&    sub test_something {
\&        my ( $test, $report ) = @_;
\&        ...
\&    }
.Ve
.Sp
This was annoying. It was doubly annoying in test control methods in case you
forgot it:
.Sp
.Vb 5
\&    sub test_setup {
\&        my ( $test, $report ) = @_;
\&        $test\->next::method; # oops, needed $report
\&        ...
\&    }
.Ve
.Sp
That second argument is still passed, but it's deprecated. It's now
recommended that you call the \f(CW\*(C`$test\->test_report\*(C'\fR method to get that.
Instead of this:
.Sp
.Vb 5
\&    sub test_froblinator {
\&        my ( $test, $report ) = @_;
\&        $report\->plan(7);
\&        ...
\&    }
.Ve
.Sp
You write this:
.Sp
.Vb 5
\&    sub test_froblinator {
\&        my $test = shift;
\&        $test\->test_report\->plan(7);
\&        ...
\&    }
.Ve
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Callbacks for tags (for example, 'critical' tags could bailout)
.IP "\(bu" 4
New test phases \- start and end suite, not just start and end class/method
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-test\-class\-moose at rt.cpan.org\*(C'\fR,
or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test\-Class\-Moose <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Class-Moose>.  I will be
notified, and then you'll automatically be notified of progress on your bug as
I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Test::Class::Moose
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker (report bugs here)
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Test\-Class\-Moose <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Test-Class-Moose>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/Test\-Class\-Moose <http://annocpan.org/dist/Test-Class-Moose>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/Test\-Class\-Moose <http://cpanratings.perl.org/d/Test-Class-Moose>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/Test\-Class\-Moose/ <http://search.cpan.org/dist/Test-Class-Moose/>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Test::Routine
.Sp
I always pointed people to this when they would ask about Test::Class +
Moose, but I would always hear \*(L"that's not quite what I'm looking for\*(R".
I don't quite understand what the reasoning was, but I strongly encourage you
to take a look at Test::Routine.
.IP "\(bu" 4
Test::Roo
.Sp
Test::Routine, but with Moo instead of Moose.
.IP "\(bu" 4
Test::Class
.Sp
xUnit-style testing in Perl.
.IP "\(bu" 4
Test::Class::Most
.Sp
Test::Class + Test::Most.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Doug Bell <doug.bell@baml.com>
.IP "\(bu" 4
Gregory Oschwald <goschwald@maxmind.com>
.IP "\(bu" 4
Jonathan C. Otsuka <djgoku@gmail.com>
.IP "\(bu" 4
Neil Bowers <neil@bowers.com>
.IP "\(bu" 4
Olaf Alders <olaf@wundersolutions.com>
.IP "\(bu" 4
Ovid <curtis\e_ovid\e_poe@yahoo.com>
.IP "\(bu" 4
Paul Boyd <pboyd@dev3l.net>
.IP "\(bu" 4
Petrea Corneliu Stefan <stefan@garage\-coding.com>
.IP "\(bu" 4
Stuckdownawell <stuckdownawell@gmail.com>
.IP "\(bu" 4
Tom Beresford <tom.beresford@bskyb.com>
.IP "\(bu" 4
Tom Heady <tom@punch.net>
.IP "\(bu" 4
Udo Oji <Velti@signor.com>
.SH "AUTHOR"
.IX Header "AUTHOR"
Curtis \*(L"Ovid\*(R" Poe <ovid@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2014 by Curtis \*(L"Ovid\*(R" Poe.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
